#include <iostream>
#include <vector>
#include <tuple>
#include <unordered_map>
#include <queue>

using namespace std;

typedef vector<vector<int>> matrix;

int encode(const matrix &m) {
	int res = 0;
	for (auto &row : m) {
		for (auto &cell : row) {
			res *= 10;
			res += cell;
		}
	}
	return res;
}
matrix decode(int x) {
	matrix ret (3, vector<int>(3));
	for (int i = 2; i >= 0; --i) {
		for (int j = 2; j >= 0; --j) {
			ret[i][j] = x%10;
			x = x/10;
		}
	}
	return ret;
}

pair<int, int> find0(const matrix &m) {
	for (int i = 2; i >= 0; --i) {
		for (int j = 2; j >= 0; --j) {
			if (!m[i][j])
				return {i, j};
		}
	}
}

bool isValid(int i, int j) {
	return (i >= 0 && i < 3 && j >= 0 && j < 3);
}

vector<int> get_neb(int x) {
	auto m = decode(x);
	int i, j;
	tie(i, j) = find0(m);
	int di = 0; int dj = -1;
	vector<int> ret;
	for (int k = 0; k < 4; k++) {
		int ni = i+di;
		int nj = j+dj;
		if (isValid(ni, nj)) {
			swap(m[i][j], m[ni][nj]);
			ret.push_back(encode(m));
			swap(m[i][j], m[ni][nj]);
		}
		swap(di, dj);
		if (k == 1) dj = 1;
	}
	return ret;
}

unordered_map<int, int> mem;

void BFS() {
	queue<int> q;
	int g = 123456780, s;
	q.push(g);
	mem[g] = 0;
	for (int steps = 1; s = q.size(); steps++) {
		while (s--) {
			for (auto v : get_neb(q.front())) {
				if (!mem.emplace(v, steps).second) continue;
				q.push(v);
			}
			q.pop();
		}
	}
}

/*

Emplace and insert return a pair:
.first ==> iterator where the element is inserted
.second ==> boolean designating if the insertion is successful

5 --> 6
5 --> 9
This fails, it won't add it

*/

int main() {

	BFS();
	matrix ret (3, vector<int>(3));
	int t = 0, tc; cin >> tc;
	while (tc--) {
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				cin >> ret[i][j];
			}
		}
		auto it = mem.find(encode(ret));
		cout << "Case " << ++t << ": ";
		if (it == mem.end()) cout << "impossible";
		else cout << it->second;
		// for (auto i = mem.begin(); i != mem.end(); i++) cout << i->first << " " << i->second << "\n";
		cout << "\n";
	}

	return 0;

}
