#include <iostream>
#include <deque>
#include <tuple>

using namespace std;

const int n = 1e3+3;

char grid[n][n];
int d[n][n];
int visited[n][n];

int vid, r, c; // initialized to zero

bool isValid(int i, int j) {
	return i >= 0 && j >= 0 && i < r && j < c;
}

int BFS01() {
	deque<pair<int, int>> q = {{0, 0}};
	visited[0][0] = ++vid;
	for (int steps = 0; int s = q.size(); steps++) {
		int i, j;
		while (s--) {
			tie(i, j) = q.front(), q.pop_front();
			if (i == r-1 && j == c-1) return steps;
			if (d[i][j] != steps) continue;
			int di = 0; int dj = -1;
			for (int k = 0; k < 4; k++) {
				int ni = i+di;
				int nj = j+dj;
				if (isValid(ni, nj)) {
					int S = steps+(grid[i][j] != grid[ni][nj]);
					if (visited[ni][nj] != vid || S < d[ni][nj]) {
						visited[ni][nj] = vid;
						d[ni][nj] = S;
						if (grid[i][j] == grid[ni][nj]) {
							++s;
							q.emplace_front(ni, nj);
						}
						else q.emplace_back(ni, nj);
					}
				}
				swap(di, dj);
				if (k == 1) dj = 1;
			}
		}
	}
}

int main() {

	int t; cin >> t;
	while (t--) {
		cin >> r >> c;
		for (int i = 0; i < r; i++) {
			for (int j = 0; j < c; j++) {
				cin >> grid[i][j];
			}
		}
		cout << BFS01() << "\n";
	}

	return 0;

}
